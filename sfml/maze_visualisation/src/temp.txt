#include<iostream>
#include<vector>
#include<algorithm>

//	Disjoint Sets Data Structure

namespace Union
{
	int fathers[100];

	int find(int x)
	{
		if(fathers[x] == x)
			return x;
		else
			return find(fathers[x]);
	}

	void unite(int x, int y)
	{
		int fx = find(x);
		int fy = find(y);
		fathers[fx] = fy;
	}
}

int main(){
	//	Initialize fathers for the disjoint sets
	for(size_t i = 0; i < 100; i++)
		Union::fathers[i] = i;


	//	Declaring the variables to load input
	std::vector < std::pair<int,  std::pair <int,  int >> > edges;

	//	Loading the input
	int n, m;
	std::cin >> n >> m;
	for(size_t i = 0; i < m; i++)
	{
		int a, b, w;
		std::cin >> a >> b >> w;
		edges.push_back(std::make_pair(w, std::make_pair(a, b)));
		// edges.emplace_back(w, std::make_pair(a, b));
	}

	//	We print a line to separate input from output
	std::cout << "\n";

	//	NOW THE KRUSKAL'S ALGORITHM BEGINS
	//	We firstly declare the variables for the MST
	int mst_weight = 0, mst_edges = 0, mst_ni = 0;

	//	STEP 1:	sort the list of edges
	std::sort(edges.begin(), edges.end());

	//	STEP 2-3:
	while(( mst_edges < n-1) || (mst_ni < m))
	{
		//	We break the edge into the three integers they describe it
		int a = edges[mst_ni].second.first;
		int b = edges[mst_ni].second.second;
		int w = edges[mst_ni].first;

		//	We check if the edge is ok to be included in the MST
		//	If a and b are in different trees (if they are on the same We will create a cycle)
		if( Union::find(a) != Union::find(b) )
		{
			//	We unite the two trees the edge connects
			Union::unite(a, b);

			//	We add the weight of the edge
			mst_weight += w;

			//	We print the edge and count it
			std::cout<< a << " " << b << " " << w << "\n";
			mst_edges++;
		}

		//	increase the index of the edge We will be chacking
		mst_ni++;
	}

	//	Presenting the WEIGHT
	std::cout << "\nWeight of the MST is " << mst_weight << "\n";
	//	THE END
}

/*	The example's input:
7 9
1 2 4
7 2 2
6 2 3
6 5 1
5 3 20
4 3 6
1 4 7
2 5 2
2 3 1

Explanation of Input:
N M
1
..  { The edges described as a b w -> meaning (edge from a to b with weight w)
M
*/



/*	The example's output:
2 3 1
6 5 1
2 5 2
7 2 2
1 2 4
4 3 6

Weight of the MST is 16
*/